# -*- coding: utf-8 -*-
"""Merge_after_toll.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t33kGQJSiltSG218tN1D4LW4BF3DPCIn
"""

import random
import matplotlib.pyplot as plt
import numpy as np
import time

"""# Boxy model

Here, we model cars as individual actors in a discrete roadway
"""

def draw_heatmap(collisions, lanes):

  collisions = np.array(collisions)
  lane_ends_x = [d for lane in lanes for d,s in enumerate(lane) if s == "x"]
  lane_ends_y = [l for l,lane in enumerate(lanes) for s in lane if s == "x"]

  plt.rcParams['figure.figsize'] = (20, 20)
  fig, ax = plt.subplots()
  im = ax.imshow(collisions)

  # Loop over data dimensions and create text annotations.
  for i in range(collisions.shape[0]):
      for j in range(collisions.shape[1]):
          text = ax.text(j, i, round(collisions[i, j]),
                        ha="center", va="center", color="w")

  # put dots over spaces where lane has ended
  ax.plot(lane_ends_x, lane_ends_y, 'p', markersize=40)

  ax.set_title("Collision heatmap")
  ax.figure.colorbar(im, ax=ax, location="bottom", orientation="horizontal")
  fig.tight_layout()
  #plt.show()


class Driver:
  def __eq__(self, other):
    return other == 'c'
  def algorithm(self):
    return 'forward'

class SimpleDriver(Driver):
  def algorithm(self,sight):
    """
    Takes in a tuple of spaces the car can see:
    0. The space directly in front
    1. The space two in front
    2. The space in the lane to the left
    3. The space in the lane to the right
    4. The space in lane to the left and behind
    5. The space in lane to right and behind

    Returns: space to move into: either
    'forward', 'merge left', 'merge right', or 'stop'
    """
    if sight[0] == " ":
      return 'forward'
    if sight[2] == " " and sight[4] == " ":
      return 'merge left'
    if sight[3] == " " and sight[5] == " ":
      return 'merge right'
    return 'stop'

"""
Currently pseudo-code
"""

class Driver2(Driver):
  """
  Lower speed ought to allow for extra safety checks, speed translates to
  0-> 5mph
  1-> 15mph
  2-> 30mph
  3-> 60mph
  """
  speed = 1
  possible_checks = [6,5,4,3]
  def algorithm(self, sight):
    checks = possible_checks[speed]
  

def generate_driver_sight(lanes, l, d):
  def space_or_none(lprime, dprime):
    if lprime >= len(lanes) or lprime < 0:
      return "x" # out of course
    if dprime < 0:
      return "x" # out of course
    if dprime >= len(lanes[0]):
      return " " # infinite space beyond scope of course
    return lanes[lprime][dprime]
  return [
      space_or_none(l, d+1),
      space_or_none(l, d+2),
      space_or_none(l-1, d),
      space_or_none(l+1, d),
      space_or_none(l-1, d-1),
      space_or_none(l+1, d-1),
  ]

def model_trapezoid(
    n_toll_booths,
    n_lanes,
    merged_distance,
    merging_rate,
    driver,
    lane_throughputs,
    timesteps,
    lane_length=100,
    lane_curve = None
    ):
  if lane_curve is None:
    # default to right trapezoidal
    lane_curve = lambda lane: (merged_distance - merging_rate * (lane - n_lanes)) if lane > n_lanes else lane_length

  def clean_lanes():
      return [
          [
              (" " if i < lane_curve(lane) else "x")
              for i in range(lane_length)
          ]
          for lane in range(n_toll_booths)
      ]

  lanes = clean_lanes()
  next_lanes = clean_lanes()

  lane_collisions = [
      [ 0 for i in range(lane_length) ]
      for lane in range(n_toll_booths)
  ]

  # legend:
  # ' ' - empty road
  # 'x' - off-road
  # 'c' - occupied by car

  # simulate driving
  for t in range(timesteps):

    # update car movement
    for l, lane in enumerate(lanes):
      for d, space in enumerate(lane):
        if space != "c":
          continue
        direction = space.algorithm(generate_driver_sight(lanes, l, d))
        new_l = (l-1) if direction == "merge left" else (
                   (l+1) if direction == "merge right" else
                   l)
        new_d = (d+1) if direction != "stop" else d

        if next_lanes[new_l][new_d] != " ":
          print(next_lanes[new_l][new_d])
          # report collision
          lane_collisions[new_l][new_d] += 1

          draw_heatmap(
              [[(0, 1)[s == 'c'] for s in lane
              ] for lane in lanes
               ],
                       lanes)
          plt.plot([new_l], [new_d], '.', markersize=60)
          plt.title("before")

          draw_heatmap(
              [[(0, 1)[s == 'c'] for s in lane
              ] for lane in next_lanes
               ],
                       lanes)
          plt.plot([new_l], [new_d], '.', markersize=60)
          plt.title("after")
          print(generate_driver_sight(lanes, l, d))
          print(direction)
          plt.show()

          return

          # for now, just delete car which would cause collision
          next_lanes[l][d] = " "
        else:
          next_lanes[new_l][new_d]  = driver()




    # generate new cars and remove old ones
    for throughput,lane in zip(lane_throughputs, next_lanes):
      if lane[0] == " ":
        if random.random() < throughput:
          lane[0] = driver()
      if lane[-1] == "c":
        lane[-1] = " "

    # get new lane state
    lanes = next_lanes
    next_lanes = clean_lanes()

  return lane_collisions, lanes

t1 = time.time()
collisions, lanes = model_trapezoid(6, 2, 20, 5, SimpleDriver, [0.01, 0.1, 0.1, 0.5, 0.8, 0.6], 10000, lane_length=25)
print("time taken:", time.time() - t1)


draw_heatmap(collisions, lanes)

